<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesser known git Commands</title>
    <link rel="stylesheet" href="/styles.css">
</head>
<body>
    <header class="hero">
        <div class="container container-center">
            <h1 class="hero-heading heading-inverted-darker">Some Lesser known git commands</h1>
            <small>2nd February 2022</small>
            <ul class="list-non-bullet">
                <li>
                    <h1 class="ow">git please</h1>
                    <p>Every developer has had the chat with their team lead about force pushing to a shared branch (i.e. don’t do it). Rebasing, amending, and squashing. are all good fun right up until you rewrite some shared history and spill duplicate commits all over your repository. Fortunately, Git won’t let you rewrite history on the server willy-nilly. You have to explicitly pass the --force option to git push to show you mean business. But force pushing is a bit heavy handed: it stomps the upstream branch with your local version, and any changes that you hadn’t already fetched are erased from history.</p>
                    <img class="hero hero-img" src="/image/please.jpeg" >
                    <p><strong>$ git config --global alias.please 'push --force-with-lease'</strong></p>
                    <p>Git’s --force-with-lease option is far more polite: it checks that your local copy of the ref that you’re overwriting is up-to-date before overwriting it. This indicates that you’ve at least fetched the changes you’re about to stomp. Since git push --force-with-lease is rather a lot to type out each time, I’ve created a polite alias for it: git please</p>
                </li>

                <li>
                    <h1 class="ow">git commend</h1>
                    <p><strong>$ git config --global alias.commend 'commit --amend --no-edit'</strong></p>
                    <p>Ever commit and then immediately realize you’d forgotten to stage a file? Fret no more! git commend quietly tacks any staged files onto the last commit you created, re-using your existing commit message. So as long as you haven’t pushed yet, no-one will be the wiser.</p>    
               </li>

               <li>
                <h1 class="ow">git it</h1>
                <p><strong>$ git config --global alias.it \
                    '!git init && git commit -m “root” --allow-empty'</strong></p>
                <p>The first commit of a repository can not be rebased like regular commits, so it’s good practice to create an empty commit as your repository root. git it both initializes your repository and creates an empty root commit in one quick step. Next time you spin up a project, don’t just add it to version control: git it!</p>    
           </li>

                <li class="list-item-inline">
                    <a class="link link-primary" href="javascript:history.back()">Go Back</a>
                </li>
            </ul>


        </div>

    </header>
</body>
</html>